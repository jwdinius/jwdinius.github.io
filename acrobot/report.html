<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Experiments with the Acrobot: Implementing a Swingup Controller and Catching a Ball">
<meta name="keywords" content="keyword,model problem,acrobot">

<title>Experiments with the Acrobot: Implementing a Swingup Controller and Catching a Ball</title>


<style type="text/css">

/* Builds on
   http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
   Many changes for DocOnce by Hans Petter Langtangen.
*/
html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
	display: block;
}

body { line-height: 1; }
ol, ul { list-style: none; }
blockquote, q {	quotes: none; }
blockquote:before, blockquote:after,
q:before, q:after { content: ''; content: none; }
table {	border-collapse: collapse; border-spacing: 0; }

body {
  font-size: 1em;
  line-height: 1.5;
  background: #e7e7e7 url(https://cdn.rawgit.com/hplgit/num-methods-for-PDEs/master/doc/web/images/body-bg.png) 0 0 repeat;
  font-family: 'Helvetica Neue', Helvetica, Arial, serif;
  text-shadow: 0 1px 0 rgba(255, 255, 255, 0.8);
  color: #6d6d6d;
  width: 620px;
  margin: 0 auto;
}

pre, code {
  font-family: "Monospace";
  margin-bottom: 30px;
  font-size: 14px;
}

code {
  border: solid 2px #ddd;
  padding: 0 3px;
}

pre {
  padding: 20px;
  color: #222;
  text-shadow: none;
  overflow: auto;
  border: solid 4px #ddd;
}

a { color: #d5000d; }
a:hover { color: #c5000c; }
ul, ol, dl { margin-bottom: 20px; }

hr {
  height: 1px;
  line-height: 1px;
  margin-top: 1em;
  padding-bottom: 1em;
  border: none;
}

b, strong { font-weight: bold; }
em { font-style: italic; }
table { width: 100%; border: 1px solid #ebebeb; }
th { font-weight: 500; }
td { border: 4px solid #ddd; text-align: center; font-weight: 300; }

/* red color: #d5000d; /*black color: #303030; gray is default */

h1 {
  font-size: 32px;
  font-weight: bold;
  margin-bottom: 8px;
  color: #303030;
}

h2 {
  font-size: 22px;
  font-weight: bold;
  margin-bottom: 8px;
  color: #303030;
}

h3 { font-size: 18px; }
p { font-weight: 300; margin-bottom: 20px; margin-top: 12px; }
a { text-decoration: none; }
p a { font-weight: 400; }

blockquote {
  font-size: 1.6em;
  border-left: 10px solid #e9e9e9;
  margin-bottom: 20px;
  padding: 0 0 0 30px;
}

ul li {
  list-style: disc inside;
  padding-left: 20px;
}

ol li {
  list-style: decimal inside;
  padding-left: 3px;
}

dl dt {
  color: #303030;
}

footer {
  background: transparent url('../images/hr.png') 0 0 no-repeat;
  margin-top: 40px;
  padding-top: 20px;
  padding-bottom: 30px;
  font-size: 13px;
  color: #aaa;
}

footer a {
  color: #666;
}
footer a:hover {
  color: #444;
}


/* #Media Queries
================================================== */

/* Smaller than standard 960 (devices and browsers) */
@media only screen and (max-width: 959px) {}

/* Tablet Portrait size to standard 960 (devices and browsers) */
@media only screen and (min-width: 768px) and (max-width: 959px) {}

/* Mobile Landscape Size to Tablet Portrait (devices and browsers) */
@media only screen and (min-width: 480px) and (max-width: 767px) {}

/* Mobile Portrait Size to Mobile Landscape Size (devices and browsers) */
@media only screen and (max-width: 479px) {}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #bababa;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #f8f8f8;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_gray_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Mathematical problem ', 1, 'math:problem', 'math:problem'),
              (' Implementation ', 1, 'implementation', 'implementation'),
              (' Results ', 1, None, '___sec2'),
              (' References ', 1, None, '___sec3')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- ------------------- main content ---------------------- -->



<center><h1>Experiments with the Acrobot: Implementing a Swingup Controller and Catching a Ball</h1></center>  <!-- document title -->

<p>
<!-- author(s): Joe Dinius -->

<center>
<b>Joe Dinius</b> 
</center>

<p>
<!-- institution(s) -->
<p>
<center><h4>Dec 10, 2016</h4></center> <!-- date -->
<p>
<b>Summary.</b> This report looks into implementing a multimodal feedback controller for the classic acrobot <a href="#sprong">[1]</a>.  The acrobot is a simple two-linked robot with two joints and control about the second joint, called the elbow (see Figure <a href="#fig:A1">1</a>).  The proposed controller is shown to stabilize the acrobot at the upright equilibrium, which is unstable.  The focus then shifts to finding an optimal policies for catching a ball both when the initial conditions are known and perturbed.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  The (in)famous acrobot. <div id="fig:A1"></div> </p></center>
<p><img src="files/A1.png" align="bottom" width=200></p>
</center>

<h2>
Table of contents</h2>

<p>
<a href="#math:problem"> Mathematical problem </a><br>
<a href="#implementation"> Implementation </a><br>
<a href="#___sec2"> Results </a><br>
<a href="#___sec3"> References </a><br>
</p>
<p>
<!-- !split -->

<h1 id="math:problem">Mathematical problem</h1>

<p>
We address the feedback control problem for the acrobot.  For a complete discussion of the dynamics of the acrobot, see Sprong <a href="#sprong">[1]</a>.  The acrobot is a wonderful demonstrative system since it exhibits rich nonlinear behavior but is still simple enough to describe mathematically.  To stabilize about the upright equilibrium, three controllers will be used: LQR, partial feedback linearization, and energy-shaping.

<p>
The LQR feedback controller will be discussed first.  This controller's region of utility is only near where the acrobot dynamics are well-described by the linearized dynamics:

$$
\begin{align}
\begin{pmatrix}
q \\ \dot q
\end{pmatrix} 
\approx
A
\begin{pmatrix}
q-q_0 \\ \dot q
\end{pmatrix}
+ 
B 
u, \label{lqr}
\end{align}
$$

<p>
where \( q \), \( q_0 \), \( A \), and \( B \) are the two angular states, the desired angular state, A is the Jacobian matrix, and \( B \) is the control Jacobian.  From this information, and through choice of appropriate symmetric positive definite matrices \( Q \) and \( R \), an LQR feedback controller that stabilizes the acrobot at the upright equilibrium when "sufficiently" close to the equilibrium.  Far enough away from the equilibrium, the LQR controller will not work.  This controller consists of a gain matrix, \( K \), and a cost-to-go matrix, \( S \).  The cost-to-go matrix determines when to switch the acrobot to using the LQR controller exclusively.  The LQR control law is:

$$
\begin{align}
u &= -K 
\begin{pmatrix}
q - q_0 \\ \dot q
\end{pmatrix}.
\label{lqr_cntrl}
\end{align}
$$

<p>
The second controller is the partial feedback linearization controller and it is valid away from the equilibrium.  We start with the acrobot manipulator equations <a href="#tedrake">[2]</a> written in a simplified form:

$$
\begin{align}
\ddot q &= H^{-1}(Bu-C), \label{manip}\\
B &= 
\begin{pmatrix}
0 \\ 1
\end{pmatrix}, \
C = 
\begin{pmatrix}
C_1 \\ C_2
\end{pmatrix}, \
H^{-1} = 
\begin{pmatrix}
a_1 & a_2 \\
a_2 & a_3
\end{pmatrix}.
\end{align}
$$

<p>
The goal for collocated PFL is to find a control law \( u \) such that \( \ddot q = y \) for some value \( y \).  This law works out to be:

$$
\begin{align}
u = \frac{1}{a_3}(y + a_2 C_1) + C_2. \label{pfl}
\end{align}
$$

<p>
The final controller is energy-shaping, and it is valid away from the upright equilibrium.  The total energy of the acrobot is the sum of the potential, \( V \), and kinetic, \( T \), energies:  \( E = T+V \).  We seek a configuration that zeros out the change in energy; this means we've reached the quilibrium.  The resulting control law is:

$$
\begin{align}
u = k (E_0-E) \dot q_2, \label{energy}
\end{align}
$$

<p>
where \( E_0 \) and \( E \) are the energy at the upright state and at the current state, respectively.

<p>
The next part of the project is concerned with the generation of optimal trajectories using piecewise polynomials.  Polynomials of the form:

$$
\begin{align}
x_i(t) = x_i(t_i) + a_1 x_i(t-t_i) + a_2 x_i^2(t-t_i) + a_3 x_i^3(t-t_i) + \ldots , \label{poly}
\end{align}
$$

<p>
where \( t_i \) is the \( i^{\text{th}} \) knot point in time.  The idea behind piecewise polynomial trajectory generation is to find a sequence of polynomials that agree with the dynamics of the acrobot up to some arbitrary derivative; a technique known as direct collocation <a href="#tedrake">[2]</a>.  This allows the generation of complex trajectories using relatively simple mathematics.

<p>
These methods generate an open loop optimal trajectory when the initial condition is known.  When the initial condition is perturbed, an LQR controller, which tracks error over time, must be implemented to track the optimal trajectory.  Additionally, since we are predominately concerned with the final state, where the ball is either caught or now, we need to add a final state constraint to the LQR controller.

<h1 id="implementation">Implementation</h1>

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Note:</b>
<p>
The implementation is built on the Drake API (see <a href="https://github.com/RobotLocomotion/drake" target="_self"><tt>Drake GitHub page</tt></a>).  The Drake package is available freely, but some of the third-party software requires additional licensing.  The Drake repo must be build locally before you can expect any of the below code to work.
</div>


<p>
The implementation of the full feedback controller is shown below:

<p>

<!-- code=matlab (!bc m) typeset with pygments style "trac" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="font-weight: bold">    function</span><span style="color: #bbbbbb"> </span>u =<span style="color: #bbbbbb"> </span><span style="color: #990000; font-weight: bold">output</span>(obj,t,~,x)<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb">      </span>q = x(<span style="color: #009999">1</span>:<span style="color: #009999">2</span>);
      qd = x(<span style="color: #009999">3</span>:<span style="color: #009999">4</span>);
      
      <span style="color: #999988; font-style: italic">% unwrap angles q(1) to [0,2pi] and q(2) to [-pi,pi]</span>
      q(<span style="color: #009999">1</span>) = q(<span style="color: #009999">1</span>) <span style="font-weight: bold">-</span> <span style="color: #009999">2</span><span style="font-weight: bold">*</span><span style="color: #999999">pi</span><span style="font-weight: bold">*</span><span style="color: #999999">floor</span>(q(<span style="color: #009999">1</span>)<span style="font-weight: bold">/</span>(<span style="color: #009999">2</span><span style="font-weight: bold">*</span><span style="color: #999999">pi</span>));
      q(<span style="color: #009999">2</span>) = q(<span style="color: #009999">2</span>) <span style="font-weight: bold">-</span> <span style="color: #009999">2</span><span style="font-weight: bold">*</span><span style="color: #999999">pi</span><span style="font-weight: bold">*</span><span style="color: #999999">floor</span>((q(<span style="color: #009999">2</span>) <span style="font-weight: bold">+</span> <span style="color: #999999">pi</span>)<span style="font-weight: bold">/</span>(<span style="color: #009999">2</span><span style="font-weight: bold">*</span><span style="color: #999999">pi</span>));

      <span style="color: #999988; font-style: italic">%%%% put your controller here %%%%</span>
      <span style="color: #999988; font-style: italic">% You might find some of the following functions useful</span>
      <span style="color: #999988; font-style: italic">% user definitions (for first part of problem, set k2=k3=0)</span>
      <span style="color: #999988; font-style: italic">% k1 = 6 shows that energy-shaping control leads to nearly constant</span>
      <span style="color: #999988; font-style: italic">% energy when looking at position relative to lower (stable)</span>
      <span style="color: #999988; font-style: italic">% equilibrium</span>
      k1 = <span style="color: #009999">6</span>; <span style="color: #999988; font-style: italic">% energy-shaping gain</span>
      k2 = <span style="color: #009999">6</span>; <span style="color: #999988; font-style: italic">% partial feedback linearization position gain</span>
      k3 = <span style="color: #009999">6</span>; <span style="color: #999988; font-style: italic">% partial feedback linearization rate gain</span>
      tol = <span style="color: #009999">500</span>; <span style="color: #999988; font-style: italic">% cost threshold for switching to LQR feedback controller</span>
      firstPart = <span style="color: #009999">0</span>; <span style="color: #999988; font-style: italic">% set to 1 when looking at energy-shaping only controller, otherwise set 0 (false)</span>
      
      <span style="color: #999988; font-style: italic">% error vector</span>
      <span style="font-weight: bold">if</span> firstPart
        e  = [q;qd] <span style="font-weight: bold">-</span> <span style="color: #999999">zeros</span>(<span style="color: #009999">4</span>,<span style="color: #009999">1</span>); <span style="color: #999988; font-style: italic">% for first part of problem (stable equilibrium)</span>
      <span style="font-weight: bold">else</span>
        e = [q;qd]<span style="font-weight: bold">-</span>[<span style="color: #999999">pi</span>;<span style="color: #009999">0</span>;<span style="color: #009999">0</span>;<span style="color: #009999">0</span>]; <span style="color: #999988; font-style: italic">% for second part of problem (unstable</span>
      <span style="color: #999988; font-style: italic">% equilibrium)</span>
      <span style="font-weight: bold">end</span>
      
      <span style="color: #999988; font-style: italic">% get dynamics parameters</span>
      [H,C,B] = obj.p.manipulatorDynamics(q,qd);
      [f,df] = obj.p.dynamics(t,[<span style="color: #999999">pi</span>;<span style="color: #009999">0</span>;<span style="color: #009999">0</span>;<span style="color: #009999">0</span>],<span style="color: #009999">0</span>);
      
      <span style="color: #999988; font-style: italic">% construct LQR </span>
      Alin = df(:,<span style="color: #009999">2</span>:<span style="color: #009999">5</span>);
      Blin = df(:,<span style="color: #009999">6</span>);
      Q = .<span style="color: #009999">5</span><span style="font-weight: bold">*</span><span style="color: #999999">diag</span>([<span style="color: #009999">1</span> <span style="color: #009999">1</span> <span style="color: #009999">1</span> <span style="color: #009999">1</span>]);
      R = .<span style="color: #009999">5</span>;
      [K,S] = lqr(Alin,Blin,Q,R);
      
      <span style="color: #999988; font-style: italic">% energy-shaping piece</span>
      com_position = obj.p.getCOM(q); <span style="color: #999988; font-style: italic">% center-of-mass position</span>
      mass = obj.p.getMass();
      gravity = obj.p.gravity;
      <span style="color: #999988; font-style: italic">% Recall that the kinetic energy for a manipulator given by .5*qd&#39;*H*qd</span>
      T = <span style="color: #009999">1</span><span style="font-weight: bold">/</span><span style="color: #009999">2</span><span style="font-weight: bold">*</span>qd<span style="font-weight: bold">&#39;*</span>H<span style="font-weight: bold">*</span>qd;
      U = <span style="font-weight: bold">-</span>mass<span style="font-weight: bold">*</span>gravity(<span style="color: #009999">3</span>)<span style="font-weight: bold">*</span>com_position(<span style="color: #009999">2</span>);
      E = T<span style="font-weight: bold">+</span>U;
      com_position_d = obj.p.getCOM([<span style="color: #999999">pi</span>;<span style="color: #009999">0</span>]);
      Ed = <span style="font-weight: bold">-</span>mass<span style="font-weight: bold">*</span>gravity(<span style="color: #009999">3</span>)<span style="font-weight: bold">*</span>com_position_d(<span style="color: #009999">2</span>);
      ue = k1<span style="font-weight: bold">*</span>(Ed <span style="font-weight: bold">-</span> E)<span style="font-weight: bold">*</span>qd(<span style="color: #009999">2</span>);
      
      <span style="color: #999988; font-style: italic">% partial feedback linearization piece</span>
      Hinv = pinv(H);
      a2 = Hinv(<span style="color: #009999">1</span>,<span style="color: #009999">2</span>); <span style="color: #999988; font-style: italic">% =H(2,1)</span>
      a3 = Hinv(<span style="color: #009999">2</span>,<span style="color: #009999">2</span>);
      y  = <span style="font-weight: bold">-</span>k2<span style="font-weight: bold">*</span>q(<span style="color: #009999">2</span>)<span style="font-weight: bold">-</span>k3<span style="font-weight: bold">*</span>qd(<span style="color: #009999">2</span>);
      up = (y<span style="font-weight: bold">+</span>a2<span style="font-weight: bold">*</span>C(<span style="color: #009999">1</span>))<span style="font-weight: bold">/</span>a3 <span style="font-weight: bold">+</span> C(<span style="color: #009999">2</span>);
      
      <span style="color: #999988; font-style: italic">% if the cost (e&#39;*S*e) is smaller than some tolerance for</span>
      <span style="color: #999988; font-style: italic">% the first time, set the closer flag so that the control input</span>
      <span style="color: #999988; font-style: italic">% should be from LQR</span>
      <span style="font-weight: bold">if</span> (e<span style="font-weight: bold">&#39;*</span>S<span style="font-weight: bold">*</span>e <span style="font-weight: bold">&lt;</span> tol <span style="font-weight: bold">&amp;&amp;</span> <span style="font-weight: bold">~</span>obj.closer <span style="font-weight: bold">&amp;&amp;</span> <span style="font-weight: bold">~</span>firstPart)
          obj.closer = <span style="color: #009999">1</span>;
      <span style="font-weight: bold">end</span>
      
      <span style="color: #999988; font-style: italic">% if we haven&#39;t gotten to within the linearization regime,</span>
      <span style="color: #999988; font-style: italic">% our control input should be the sum of partial feedback</span>
      <span style="color: #999988; font-style: italic">% linearization and energy-shaping inputs</span>
      <span style="font-weight: bold">if</span> (<span style="font-weight: bold">~</span>obj.closer)
          u  = up<span style="font-weight: bold">+</span>ue;
      <span style="color: #999988; font-style: italic">% otherwise, if we are in a region where the linearization</span>
      <span style="color: #999988; font-style: italic">% is valid, use LQR gain applied to error vector</span>
      <span style="font-weight: bold">else</span>
          u = <span style="font-weight: bold">-</span>K<span style="font-weight: bold">*</span>e;
      <span style="font-weight: bold">end</span>
      <span style="color: #999988; font-style: italic">%%%% end of your controller %%%%</span>
      
      <span style="color: #999988; font-style: italic">% leave this line below, it limits the control input to [-20,20]</span>
      u = max(min(u,<span style="color: #009999">20</span>),<span style="font-weight: bold">-</span><span style="color: #009999">20</span>);
      <span style="color: #999988; font-style: italic">% This is the end of the function</span>
    <span style="font-weight: bold">end</span>
</pre></div>
<p>
The implementation of the trajectory optimization for catching the ball is:

<p>

<!-- code=matlab (!bc mpro) typeset with pygments style "trac" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="font-weight: bold">function</span><span style="color: #a61717; background-color: #e3d2d2"> [</span><span style="color: #990000; font-weight: bold">p</span>,xtraj,utraj,v,x0] = pset5_catch
p = PlanarRigidBodyManipulator(<span style="color: #bb8844">&#39;Acrobot.urdf&#39;</span>);
p = p.addRobotFromURDF(<span style="color: #bb8844">&#39;../../systems/plants/test/ball.urdf&#39;</span>,<span style="color: #999999">zeros</span>(<span style="color: #009999">3</span>,<span style="color: #009999">1</span>),<span style="color: #999999">zeros</span>(<span style="color: #009999">3</span>,<span style="color: #009999">1</span>),struct(<span style="color: #bb8844">&#39;floating&#39;</span>,true));
p = p.setInputLimits(<span style="font-weight: bold">-</span><span style="color: #009999">40</span>,<span style="color: #009999">40</span>);

N = <span style="color: #009999">31</span>;
T = <span style="color: #009999">3</span>;

x0 = [<span style="color: #009999">0</span>;<span style="color: #009999">0</span>;<span style="font-weight: bold">-</span><span style="color: #009999">10</span>;<span style="color: #009999">3</span><span style="font-weight: bold">*</span><span style="color: #009999">5</span><span style="font-weight: bold">-</span><span style="color: #009999">2</span><span style="font-weight: bold">-</span><span style="color: #009999">4.5</span><span style="font-weight: bold">*</span><span style="color: #009999">9.81</span>;<span style="color: #009999">0</span>;<span style="color: #009999">0</span>;<span style="color: #009999">0</span>;<span style="color: #009999">3</span>;<span style="color: #009999">3</span><span style="font-weight: bold">*</span><span style="color: #009999">9.81</span><span style="font-weight: bold">-</span><span style="color: #009999">5</span>;<span style="color: #009999">0</span>];

t_init = <span style="color: #999999">linspace</span>(<span style="color: #009999">0</span>,T,N);

<span style="color: #999988; font-style: italic">% ********YOUR CODE HERE ********</span>
<span style="color: #999988; font-style: italic">% Set the initial guess for x and u, should be dim(x) by N and dim(u) by N</span>
<span style="color: #999988; font-style: italic">% respectively</span>
x_init_vec = <span style="color: #999999">rand</span>(<span style="color: #999999">length</span>(x0),N);
u_init_vec = <span style="color: #999999">rand</span>(<span style="color: #009999">1</span>,N);
<span style="color: #999988; font-style: italic">% *******************************</span>

traj_init.x = PPTrajectory(foh(t_init,x_init_vec));
traj_init.u = PPTrajectory(foh(t_init,u_init_vec));
traj_init.x = traj_init.x.setOutputFrame(p.getStateFrame);
traj_init.u = traj_init.u.setOutputFrame(p.getInputFrame);

traj_opt =  DircolTrajectoryOptimization(p,N,[T<span style="font-weight: bold">/</span><span style="color: #009999">2</span> T]);

<span style="color: #999988; font-style: italic">% FOR THE SECOND PART, YOU MIGHT WANT THIS LINE</span>
<span style="color: #999988; font-style: italic">%traj_opt = traj_opt.addFinalCost(@(tt,x) final_state_obj(p,tt,x));</span>

traj_opt = traj_opt.addRunningCost(@running_cost_fun);
traj_opt = traj_opt.addStateConstraint(ConstantConstraint(x0),<span style="color: #009999">1</span>);
traj_opt = traj_opt.setSolver(<span style="color: #bb8844">&#39;fmincon&#39;</span>);
traj_opt = traj_opt.setSolverOptions(<span style="color: #bb8844">&#39;fmincon&#39;</span>,<span style="color: #bb8844">&#39;Algorithm&#39;</span>,<span style="color: #bb8844">&#39;sqp&#39;</span>);

catchConstraint = FunctionHandleConstraint([<span style="color: #009999">0</span>;<span style="color: #009999">0</span>],[<span style="color: #009999">0</span>;<span style="color: #009999">0</span>],<span style="color: #009999">10</span>,@(x) final_state_con(p,x),<span style="color: #009999">1</span>);

traj_opt = traj_opt.addStateConstraint(catchConstraint,N);

tic
[xtraj,utraj,z,F,info] = traj_opt.solveTraj(t_init,traj_init);
toc

v = p.constructVisualizer;
v.axis = [<span style="font-weight: bold">-</span><span style="color: #009999">5</span> <span style="color: #009999">5</span> <span style="font-weight: bold">-</span><span style="color: #009999">5</span> <span style="color: #009999">5</span>];
v.playback(xtraj)
v.drawWrapper(<span style="color: #009999">3</span>,xtraj.eval(<span style="color: #009999">3</span>))
v.draw_axes = <span style="color: #009999">1</span>;
<span style="color: #999988; font-style: italic">%playbackMovie(v,xtraj,&#39;first_catch.avi&#39;);</span>
xf = xtraj.eval(<span style="color: #009999">3</span>);
[<span style="font-weight: bold">~</span>,dcon] = final_state_con(p,xf);
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">function</span><span style="color: #bbbbbb"> </span>[f,df] =<span style="color: #bbbbbb"> </span><span style="color: #990000; font-weight: bold">running_cost_fun</span>(h,x,u)<span style="color: #bbbbbb"></span>
f = u^<span style="color: #009999">2</span>;
df = [<span style="color: #009999">0</span> <span style="color: #999999">zeros</span>(<span style="color: #009999">1</span>,<span style="color: #009999">10</span>) <span style="color: #009999">2</span><span style="font-weight: bold">*</span>u];
<span style="font-weight: bold">end</span>

<span style="font-weight: bold">function</span><span style="color: #bbbbbb"> </span>[f,df] =<span style="color: #bbbbbb"> </span><span style="color: #990000; font-weight: bold">final_state_con</span>(obj,x)<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb">  </span>q = x(<span style="color: #009999">1</span>:<span style="color: #009999">5</span>);
  qd = x(<span style="color: #009999">6</span>:<span style="color: #009999">10</span>);
  kinsol = obj.doKinematics(q);
  
  <span style="color: #999988; font-style: italic">% body index, so p.body(3) is the lower link</span>
  hand_body = <span style="color: #009999">3</span>;
  
  <span style="color: #999988; font-style: italic">% position of the &quot;hand&quot; on the lower link, 2.1m is the length</span>
  pos_on_hand_body = [<span style="color: #009999">0</span>;<span style="font-weight: bold">-</span><span style="color: #009999">2.1</span>];
  
  <span style="color: #999988; font-style: italic">% Calculate position of the hand in world coordinates</span>
  <span style="color: #999988; font-style: italic">% the gradient, dHand_pos, is the derivative w.r.t. q</span>
  [hand_pos,dHand_pos] = obj.forwardKin(kinsol,hand_body,pos_on_hand_body);
  
  <span style="color: #999988; font-style: italic">% ********YOUR CODE HERE ********</span>
  <span style="color: #999988; font-style: italic">% Calculate f and the gradient df/dx</span>
  <span style="color: #999988; font-style: italic">% f should be [0;0] if and only if the hand_pos calculated above equals</span>
  <span style="color: #999988; font-style: italic">% the current position of the ball</span>
  <span style="color: #999988; font-style: italic">% DO NOT simply pre-calculate the position of the ball at t=3</span>
  <span style="color: #999988; font-style: italic">% the final time of the trajectory might not be 3!</span>
  f = [x(<span style="color: #009999">3</span>)<span style="font-weight: bold">-</span>hand_pos(<span style="color: #009999">1</span>);x(<span style="color: #009999">4</span>)<span style="font-weight: bold">-</span>hand_pos(<span style="color: #009999">2</span>)];
  df_b = [<span style="color: #009999">0</span> <span style="color: #009999">0</span> <span style="color: #009999">1</span> <span style="color: #009999">0</span> <span style="color: #009999">0</span>;<span style="color: #009999">0</span> <span style="color: #009999">0</span> <span style="color: #009999">0</span> <span style="color: #009999">1</span> <span style="color: #009999">0</span>];
  df = [df_b<span style="font-weight: bold">-</span>dHand_pos, <span style="color: #999999">zeros</span>(<span style="color: #009999">2</span>,<span style="color: #999999">length</span>(q))];
  <span style="color: #999988; font-style: italic">% *******************************</span>
<span style="font-weight: bold">end</span>


<span style="font-weight: bold">function</span><span style="color: #bbbbbb"> </span>[f,df] =<span style="color: #bbbbbb"> </span><span style="color: #990000; font-weight: bold">final_state_obj</span>(obj,T,x)<span style="color: #bbbbbb"></span>
<span style="color: #bbbbbb"> </span><span style="color: #999988; font-style: italic">% ********YOUR CODE HERE ********</span>
 <span style="color: #999988; font-style: italic">% For the second part, calculate a cost that rewards a catch point higher</span>
 <span style="color: #999988; font-style: italic">% in the air. There are lots of ways to do this, for this problem.</span>
 <span style="color: #999988; font-style: italic">% the derivative df = [df/dT df/dx]</span>
 <span style="color: #999988; font-style: italic">% where T is the final time.</span>
 <span style="color: #999988; font-style: italic">% Some solutions will use T, others may not.</span>
 f = <span style="color: #009999">100</span>^<span style="color: #009999">2</span><span style="font-weight: bold">*</span>T; <span style="color: #999988; font-style: italic">% try to minimize time</span>
 df = <span style="color: #999999">zeros</span>(<span style="color: #999999">length</span>(f),<span style="color: #009999">11</span>);
 df(<span style="color: #009999">1</span>) = <span style="color: #009999">100</span>^<span style="color: #009999">2</span>;
 <span style="color: #999988; font-style: italic">% *******************************</span>
<span style="font-weight: bold">end</span>
</pre></div>
<p>
When the initial condition that generated the optimal trajectory has been perturbed, and additional LQR controller needs to be implemented

<p>

<!-- code=matlab (!bc m) typeset with pygments style "trac" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span></span><span style="color: #999988; font-style: italic">% RUN THIS to generate your solution</span>
megaclear

[p,xtraj,utraj,v,x0] = pset5_catch;

<span style="color: #999988; font-style: italic">% if you want to display the trajectory again</span>
<span style="color: #999988; font-style: italic">%v.playback(xtraj);</span>

<span style="color: #999988; font-style: italic">% ********YOUR CODE HERE ********</span>
<span style="color: #999988; font-style: italic">% Set Q, R, and Qf for time varying LQR</span>
<span style="color: #999988; font-style: italic">% See problem statement for instructions here</span>
xf = xtraj.eval(<span style="color: #009999">3</span>);
q = xf(<span style="color: #009999">1</span>:<span style="color: #009999">5</span>);
qd = xf(<span style="color: #009999">6</span>:<span style="color: #009999">10</span>);
options = struct();
options.compute_gradients = true;
kinsol = p.doKinematics(q,qd,options);

<span style="color: #999988; font-style: italic">% body index, so p.body(3) is the lower link</span>
hand_body = <span style="color: #009999">3</span>;

<span style="color: #999988; font-style: italic">% position of the &quot;hand&quot; on the lower link, 2.1m is the length</span>
pos_on_hand_body = [<span style="color: #009999">0</span>;<span style="font-weight: bold">-</span><span style="color: #009999">2.1</span>];

<span style="color: #999988; font-style: italic">% Calculate position of the hand in world coordinates</span>
<span style="color: #999988; font-style: italic">% the gradient, dHand_pos, is the derivative w.r.t. q</span>
[hand_pos,dHand_pos,ddHand_pos] = p.forwardKin(kinsol,hand_body,pos_on_hand_body);

<span style="color: #999988; font-style: italic">%Q = .05*eye(10);</span>
Q = <span style="color: #999999">zeros</span>(<span style="color: #009999">10</span>);
R = .<span style="color: #009999">05</span>;
Qf = <span style="color: #999999">zeros</span>(<span style="color: #009999">10</span>);
d2fdxb2 = <span style="color: #009999">2</span>;
d2fdzb2 = <span style="color: #009999">2</span>;
d2fdxbdtht1 = <span style="font-weight: bold">-</span><span style="color: #009999">2</span><span style="font-weight: bold">*</span>dHand_pos(<span style="color: #009999">1</span>,<span style="color: #009999">1</span>); <span style="color: #999988; font-style: italic">%\partial^2 f / \partial x_b \partial \theta_1</span>
d2fdxbdtht2 = <span style="font-weight: bold">-</span><span style="color: #009999">2</span><span style="font-weight: bold">*</span>dHand_pos(<span style="color: #009999">1</span>,<span style="color: #009999">2</span>);
d2fdzbdtht1 = <span style="font-weight: bold">-</span><span style="color: #009999">2</span><span style="font-weight: bold">*</span>dHand_pos(<span style="color: #009999">2</span>,<span style="color: #009999">1</span>);
d2fdzbdtht2 = <span style="font-weight: bold">-</span><span style="color: #009999">2</span><span style="font-weight: bold">*</span>dHand_pos(<span style="color: #009999">2</span>,<span style="color: #009999">2</span>);
d2fdtht12 = <span style="color: #009999">2</span><span style="font-weight: bold">*</span>(dHand_pos(<span style="color: #009999">1</span>,<span style="color: #009999">1</span>)^<span style="color: #009999">2</span><span style="font-weight: bold">+</span>dHand_pos(<span style="color: #009999">2</span>,<span style="color: #009999">1</span>)^<span style="color: #009999">2</span>);
d2fdtht1dtht2 = <span style="color: #009999">2</span><span style="font-weight: bold">*</span>(dHand_pos(<span style="color: #009999">1</span>,<span style="color: #009999">1</span>)<span style="font-weight: bold">*</span>dHand_pos(<span style="color: #009999">1</span>,<span style="color: #009999">2</span>) <span style="font-weight: bold">+</span> dHand_pos(<span style="color: #009999">2</span>,<span style="color: #009999">1</span>)<span style="font-weight: bold">*</span>dHand_pos(<span style="color: #009999">2</span>,<span style="color: #009999">2</span>));
d2fdtht22 = <span style="color: #009999">2</span><span style="font-weight: bold">*</span>(dHand_pos(<span style="color: #009999">1</span>,<span style="color: #009999">2</span>)^<span style="color: #009999">2</span><span style="font-weight: bold">+</span>dHand_pos(<span style="color: #009999">2</span>,<span style="color: #009999">2</span>)^<span style="color: #009999">2</span>);
Qf(<span style="color: #009999">1</span>:<span style="color: #009999">4</span>,<span style="color: #009999">1</span>:<span style="color: #009999">4</span>) = [d2fdtht12 d2fdtht1dtht2 d2fdxbdtht1 d2fdzbdtht1
               d2fdtht1dtht2 d2fdtht22 d2fdxbdtht2 d2fdzbdtht2
               d2fdxbdtht1 d2fdxbdtht2 d2fdxb2 <span style="color: #009999">0</span>
               d2fdzbdtht1 d2fdzbdtht2 <span style="color: #009999">0</span> d2fdzb2];
<span style="color: #999988; font-style: italic">%Qf = 10*Qf;</span>
<span style="color: #999988; font-style: italic">%Qf = 60*Qf;</span>
<span style="color: #999988; font-style: italic">% *******************************</span>
options.sqrtmethod=false;
c = p.tvlqr(xtraj,utraj,Q,R,Qf,options);
sys_cl = p.feedback(c);

<span style="color: #999988; font-style: italic">%%</span>
x0_test = x0;
x0_test(<span style="color: #009999">3</span>) = x0(<span style="color: #009999">3</span>) <span style="font-weight: bold">+</span> .<span style="color: #009999">1</span>;
traj_test_1 = sys_cl.simulate(xtraj.tspan,x0_test);
v.drawWrapper(traj_test_1.tspan(<span style="color: #009999">2</span>),traj_test_1.eval(traj_test_1.tspan(<span style="color: #009999">2</span>)));

x0_test = x0 <span style="font-weight: bold">+</span> .<span style="color: #009999">02</span><span style="font-weight: bold">*</span>(<span style="color: #999999">rand</span>(<span style="color: #009999">10</span>,<span style="color: #009999">1</span>) <span style="font-weight: bold">-</span> <span style="color: #009999">1</span>);
traj_test_2 = sys_cl.simulate(xtraj.tspan,x0_test);
v.drawWrapper(traj_test_2.tspan(<span style="color: #009999">2</span>),traj_test_2.eval(traj_test_2.tspan(<span style="color: #009999">2</span>)));
<span style="color: #999988; font-style: italic">%playbackMovie(v,traj_test_2,&#39;catch_perturb.avi&#39;);</span>
</pre></div>

<h1 id="___sec2">Results </h1>
First, consider the case where the acrobot tries to achieve the upright equilibrium without LQR.

<p>

<div>
<video  loop controls width='400' height='365' preload='none'>
    <source src='files/swingup_cloop_noLQR.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
</video>
</div>
<p><em>The swingup controller fails to achieve the equilibrium point. <div id="su_nolqr"></div></em></p>

<p>
Now, add the LQR feedback controller:

<p>

<div>
<video  loop controls width='400' height='365' preload='none'>
    <source src='files/swingup_cloop.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
</video>
</div>
<p><em>Adding LQR stabilizes the acrobot. <div id="su_lqr"></div></em></p>

<p>
The result of the open loop optimization for catching a ball under perfect knowledge of initial condition:

<p>

<div>
<video  loop controls width='400' height='365' preload='none'>
    <source src='files/first_catch.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
</video>
</div>
<p><em>Open loop optimal trajectory catches ball. <div id="ol_catch"></div></em></p>

<p>
When the initial condition is perturbed, but the original open loop optimization is used, a trajectory can result which does not catch the ball:

<p>

<div>
<video  loop controls width='400' height='365' preload='none'>
    <source src='files/nocatch_perturb.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
</video>
</div>
<p><em>Perturbed optimal trajectory fails to catch the ball. <div id="cl_nocatch"></div></em></p>

<p>
To fix this, an LQR feedback controller with final cost constraint can be implemented that will penalize the acrobot for states far from where the ball should be caught.

<p>

<div>
<video  loop controls width='400' height='365' preload='none'>
    <source src='files/catch_perturb.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
</video>
</div>
<p><em>Closed loop optimal trajectory catches ball when initial condition has been perturbed. <div id="cl_catch"></div></em></p>

<p>
<div class="alert alert-block alert-summary alert-text-normal">
<b>Summary.</b>
<p>

<ol>
<li> A multimodal controller employing (1) LQR, (2) partial feedback linearization, and (3) energy-shaping controllers was implemented to stabilize the acrobot about its upright equilibrium.</li>
<li> The LQR controller is required for stabilization once the acrobot gets close to the equilibrium point.  Close can be defined by the cost-to-go matrix \( S \).</li>
<li> Open loop trajectory optimization was used to catch a ball with the acrobot from an arbitrary initial condition.</li>
<li> When the initial condition used to generate the optimal trajectory is perturbed, the acrobot no longer catches the ball.  An LQR controller with final state constraint can be implemented which tracks the original optimal trajectory and catches the ball.</li>
</ol>
</div>


<h1 id="___sec3">References </h1>

<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="sprong"></div> <b>M. Sprong</b>. 
    The Swingup Control Problem for the Acrobot,
    <em>IEEE Control Systems</em>,
    1996.</li>
 <li> <div id="tedrake"></div> <b>R. Tedrake</b>. 
    <em>Underactuated Robotics: Algorithms for Walking, Running, Swimming, Flying, and Manipulation</em>,
    MIT,
    2016.</li>
</ol>

<!-- end bibliography -->

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

