<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Headset Tracking for VR/AR | Joe Dinius, Ph.D.</title> <meta name="author" content="Joe Dinius, Ph.D."> <meta name="description" content="orientation estimation using the MPU-6050/9150 IMU"> <meta name="keywords" content="robotics, autonomy, math, optimization, controltheory, planning, computervision"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?53ca2be8c4ec0d533ef79017d1a2d734"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jwdinius.github.io/blog/2018/headset/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Joe </span>Dinius, Ph.D.</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">git</a> </li> <li class="nav-item "> <a class="nav-link" href="/learning/">learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/resumeDiniusTargeted.pdf">resume</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Headset Tracking for VR/AR</h1> <p class="post-meta">July 1, 2018</p> <p class="post-tags"> <a href="/blog/2018"> <i class="fa-solid fa-calendar fa-sm"></i> 2018 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h3 id="summary">Summary</h3> <p>I had been looking into the Oculus Rift + Touch for awhile, but I knew next-to-nothing about the math behind its tracking algorithms. A few months back, I read a Medium article where some guys had built their own inexpensive open-source virtual reality headset. I found the project on <a href="https://github.com/relativty/Relativ" rel="external nofollow noopener" target="_blank">Github</a>, looked through their implementation and saw that there wasn’t much in the way of headset tracking, yet. I saw that they used an IMU - inertial measurement unit - for estimating rotations from raw measurements. From my experience with tracking systems, this seemed a suboptimal approach because of sensor noise, bias, etc… so I decided to dig-in deep and add inertial tracking. Doing this, I believed, would improve the VR experience by avoiding spurious orientation estimates due to IMU issues. In this post, I will talk about my experience researching and implementing a tracking filter in the project. See <a href="https://github.com/relativty/Relativ/blob/master/src/main/main.ino" rel="external nofollow noopener" target="_blank">here</a> for the algorithm implementation.</p> <h3 id="the-approach-with-all-of-the-gory-math">The Approach, with all of the Gory Math</h3> <p>The approach I’m going to discuss can be found <a href="http://vr.cs.uiuc.edu/vrch9.pdf" rel="external nofollow noopener" target="_blank">here</a>. As a prereq, you should have a background in the mathematics of <a href="http://mathworld.wolfram.com/Quaternion.html" rel="external nofollow noopener" target="_blank">quaternions</a>, because the approach I took utilizes them heavily. Briefly, a quaternion can be thought of as an object that parametrizes a rotation. Firstly, there is an <em>axis of rotation</em>, which is a unit vector \(\hat{\mathbf{v}}\) that a point, or set of points, is rotated about. The second parameter of a quaternion is the <em>angle of rotation</em>, a scalar \(\theta\). Putting these two things together, we have a quaternion \(\tilde{q}(\mathbf{v}, \theta)\) that describes a rotation <em>about</em> \(\hat{\mathbf{v}}\) with magnitude \(0 \le \theta \le 2 \pi\). Quaternions are conceptually similar to <a href="https://en.wikipedia.org/wiki/Rotation_matrix" rel="external nofollow noopener" target="_blank">Euler rotation matrices</a>, however <a href="https://en.wikipedia.org/wiki/Rotation_matrix#Ambiguities" rel="external nofollow noopener" target="_blank">quaternions are preferred</a> because of some undesirable properties of rotation matrices.</p> <p>My first step when trying to improve upon existing projects is usually to understand what data is available already. The project already included an IMU, either the <a href="https://playground.arduino.cc/Main/MPU-6050" rel="external nofollow noopener" target="_blank">6-axis MPU-6050</a> or the <a href="https://playground.arduino.cc/Main/MPU-9150" rel="external nofollow noopener" target="_blank">9-axis MPU-9150</a>, which output an acceleration vector - 3 axes, an angular velocity vector - 3 more axes, and, for the MPU-9150, a magnetic direction vector - 3 more axes. I will discuss the contribution of all of these measurement quantities in course, but I will begin with the angular velocity vector, \(\mathbf{\omega}\).</p> <p align="center"> <img src="/assets/img/coords.png"> </p> <p>See above for a picture representing <em>global</em> and <em>local</em>, or <em>body</em>, coordinate systems. The global frame has coordinates with “primes”, e.g. \(x'\). <em>Important</em>: The above image is stock; for the discussions below, replace \(z\) in the above image with \(y\), \(x\) with \(z\), and \(y\) with \(x\).</p> <p>A note on notation: I use \(\hat{-}\)’s for unit vectors and \(\tilde{-}\)’s for estimated quantities.</p> <p>The angular velocity vector, \(\mathbf{\omega}\), is a measurement of angular rotation rates about a set of principle axes, aka a body coordinate system. \(\mathbf{\omega} \equiv [\omega_x, \omega_y, \omega_z]^T\). As with most sensors, the output needs to be calibrated to account for temperature effects, bias, scaling, etc… The calibrated measurement, \(\tilde{\mathbf{\omega}}\), can be written as</p> \[\tilde{\mathbf{\omega}} = A \mathbf{\omega} + \mathbf{b}\] <p>\(A\) is a \(3 \times 3\)-matrix and \(\mathbf{b}\) is a \(3 \times 1\) bias vector. The coefficients of \(A\) and \(\mathbf{b}\) are determined during a <a href="https://github.com/kkpoon/CalibrateMPU6050" rel="external nofollow noopener" target="_blank">calibration</a> procedure. The normalized vector</p> \[\hat{\mathbf{v}} = \frac{\tilde{\mathbf{\omega}}}{||\tilde{\mathbf{\omega}}||}\] <p>forms the axis of rotation of a quaternion, and the amount of angle change over the current timestep, \(\Delta t\), \(\Delta \tilde{\theta}_k = ||\tilde{\mathbf{\omega}}|| \Delta t\), is the magnitude of rotation of the <em>same</em> quaternion.</p> <p>This quaternion, \(\Delta \tilde{q}_k \equiv q(\hat{\mathbf{v}}, \Delta \tilde{\theta}_k)\), represents an incremental change in estimated orientation from a previous state described by the quaternion \(\tilde{q}_{k-1}\). The orientation at the current timestep, \(k \Delta t\), can be updated recursively</p> \[\tilde{q}_k = \Delta \tilde{q}_k * \tilde{q}_{k-1}\] <p>where <code class="language-plaintext highlighter-rouge">*</code> is the quaternion product and, yes, order does matter. This is because quaternion algebra, like matrix algebra, is non-<a href="https://en.wikipedia.org/wiki/Abelian_group" rel="external nofollow noopener" target="_blank">Abelian</a>.</p> <p>Ok, so we have a quaternion that represents the <em>estimated</em> headset’s orientation at some timestep, \(k \Delta t\) based on the calibrated angular velocity reading. It turns out that these estimates can become unreliable over time due to a phenomena known as <a href="https://electronics.stackexchange.com/questions/16105/what-affects-imu-inertial-measurement-unit-accuracy" rel="external nofollow noopener" target="_blank">IMU drift</a>. This drift error in our estimate can be decomposed as tilt and yaw errors. The tilt error, denoted \(d_{tilt}\), is the magnitude of difference between the estimated quaternion and truth in the <a href="http://www.machinedesign.com/engineering-essentials/what-s-difference-between-pitch-roll-and-yaw" rel="external nofollow noopener" target="_blank">pitch and roll</a> channels, whereas yaw error, \(d_{yaw}\), comes from the remaining yaw channel. Since these channels represent rotations about orthogonal axes, the total error, \(d\), can be written as the product of quaternions, \(d = d_{tilt} * d_{yaw}\). Somewhat confusingly, order does not matter here, because whether you apply the yaw or tilt correction first, the end result will be the same.</p> <p>I have only considered the <em>true</em> drift error in the previous paragraph. In practice, however, one can usually only compute an estimate of the drift errors discussed. I will now go through how to compute these estimates.</p> <h4 id="tilded_tilt">\(\tilde{d}_{tilt}\)</h4> <p align="center"> <img src="/assets/img/tilt.png"> Copyright 2015,2016 Steven M. LaValle </p> <p>Tilt error is due to the estimated “up” vector, \(\tilde{\mathbf{u}} = [\tilde{u}_x, \tilde{u}_y, \tilde{u}_z]\), being out-of-alignment with the <em>actual</em> “up” vector, the \(+y\)-axis. If the IMU is only rotating, not translating, this is an ok approach, but it will break down if the IMU is accelerating. This approach hinges on the fact that the measured IMU acceleration needs to be very nearly the 9.8 meters-per-second-squared of gravitational acceleration. For a VR headset, if the wearer is seated in a chair, this seems a decent assumption. The vector \(\tilde{\mathbf{u}}\) is computed by rotating the calibrated acceleration measurement vector \(\tilde{\mathbf{a}}\) into global coordinates:</p> \[\tilde{\mathbf{u}} = \tilde{q}_k * \tilde{\mathbf{a}} * \tilde{q}_k^{-1}\] <p>Now, the angular difference between the global \(y\)-axis and \(\tilde{\mathbf{u}}\) can be computed with the <a href="http://mathworld.wolfram.com/LawofCosines.html" rel="external nofollow noopener" target="_blank">law-of-cosines</a>:</p> \[\tilde \phi = \cos^{-1} \bigl ( \frac{\tilde{\mathbf{u}} \cdot \hat{\mathbf{y}}}{||\tilde{\mathbf{u}}||} \bigr ),\] <p>with \(\hat{\mathbf{y}} = [0, 1, 0]^T\). We have the rotation angle for our quaternion, now we need the axis. The tilt-axis, \(\tilde{\mathbf{t}}\) is the vector we need to rotate about to bring \(\tilde{\mathbf{u}}\) and \(\hat{\mathbf{y}}\) into alignment. Such an axis would need to be orthogonal to <em>both</em> \(\tilde{\mathbf{u}}\) and \(\hat{\mathbf{y}}\). There are two choices based upon directionality, the one associated with the <em>positive</em> rotation -from \(\tilde{\mathbf{u}}\) <em>towards</em> \(\hat{\mathbf{y}}\)- is:</p> \[\tilde{\mathbf{t}} = \begin{bmatrix} \tilde{u}_z \\ 0 \\ -\tilde{u}_x \\ \end{bmatrix}\] <p>The tilt error can now be written as a quaternion:</p> \[\tilde{d}_{tilt} = q \bigl ( \frac{\tilde{\mathbf{t}}}{||\tilde{\mathbf{t}}||}, \hat \phi \bigr )\] <h4 id="tilded_yaw-but-only-if-you-have-the-mpu-9150-or-equivalent">\(\tilde{d}_{yaw}\), but only if you have the MPU-9150, or equivalent</h4> <p>Tilt error only estimates drift in pitch and roll, but what about yaw? A priori knowledge about gravity won’t help here, so the measured acceleration won’t be of any use. If we were able to have some way of recognizing a landmark in the \(xz\)-plane with the IMU, then we could compare our estimate of that landmark’s position to our a priori estimate. The magnetic north-pole is such a landmark, and if we have the MPU-9150, or equivalent, we have a magnetic compass that will generate a calibrated measurement, \(\tilde{\mathbf{m}}\), that we can rotate and compare to true north. We can define our global coordinate system such that the \(z\)-axis is aligned <em>opposite</em> to true north. Our estimate of true north, \(\tilde{\mathbf{n}}\) then follows much the same as the tilt error calculations:</p> \[\tilde{\mathbf{n}} = \tilde{q}_k * \tilde{\mathbf{m}} * \tilde{q}_k^{-1},\] <p>from which we compute an angular offset:</p> \[\hat \psi = \cos^{-1} \bigl ( \frac{-\tilde{\mathbf{n}} \cdot \hat{\mathbf{z}}}{||\tilde{\mathbf{n}}||} \bigr ).\] <p>The axis of rotation is just \(\hat{\mathbf{y}}\), the yaw axis, from which the estimated yaw drift is computed:</p> \[\tilde{d}_{yaw} = q \bigl ( \hat{\mathbf{y}}, \hat \psi \bigr )\] <p>If the magnetic compass reading is not available, \(\tilde{d}_{yaw}\) is set to the identity quaternion.</p> <h4 id="putting-it-all-together">Putting it all Together</h4> <p>The estimated error quaternion, \(\tilde{d}\), can be deconstructed into a rotation axis and an angle. Let’s call the angle $\theta$ and the axis \(\hat{\mathbf{v}}\). Using these quantities, we can construct a <em>complementary estimate</em></p> \[\tilde{q}_k' = q(\hat{\mathbf{v}}, -\alpha \theta) * \tilde{q}_k\] <p>with \(\alpha\) as a weighting factor with \(0 \le \alpha \le 1\). Increasing \(\alpha\) will more heavily compensate for drift in your estimate.</p> <p>The parameter \(\alpha\) should be selected heuristically; literally, an “eyeball-test”. <img class="emoji" title=":smiley:" alt=":smiley:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png" height="20" width="20"></p> <h3 id="the-implementation">The Implementation</h3> <p>You can check out the actual implementation <a href="https://github.com/relativty/Relativ/blob/master/src/main/main.ino" rel="external nofollow noopener" target="_blank">here</a>.</p> <p>I would like to point out just a few things about the <a href="https://www.i2cdevlib.com/" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">i2cdev</code></a> library:</p> <ul> <li>It has a pretty nice API. The <code class="language-plaintext highlighter-rouge">get*</code>’s and <code class="language-plaintext highlighter-rouge">set*</code>’s are well named and use camel-case consistently. Additionally, A lot of methods for accessing raw measurements and computing intermediate estimates from them are exposed. For example, the gravity estimate associated with the current orientation quaternion can be polled directly with <code class="language-plaintext highlighter-rouge">dmpGetGravity(&amp;,&amp;)</code>, which returns the estimated “up” vector.</li> <li>Quaternions and vectors are supported out-of-the-box, with methods to do useful things like normalization, compute products, etc…</li> <li>For the most part, everything is very simple and intuitive.</li> </ul> <p>All necessary math operations were provided by either <code class="language-plaintext highlighter-rouge">i2cdev</code> or Arduino; no custom functions were written. This was really nice because I feel it made the implementation cleaner and easier to work through.</p> <h3 id="parting-thoughts">Parting Thoughts</h3> <p>If you have made it this far, then congratulations are in order! The details in this post can be very difficult to get through without a significant background in rotational math; specifically quaternions and vectors. I have tried to pare down the explanation to only the bits that I found essential. I have also tried, whenever possible, to include pictures so that you, the reader, could visualize what was going on.</p> <p>I wanted to write this post in an ongoing effort to engage my mind in thinking on how to explain what I work on so that most others can understand. In that sense it is mostly for me, but in another sense I really do want to ensure that someone reading this would find something that they could recall and refer back to when working on similar problems. If you feel something could be clearer, please let me know. Thanks for reading!</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Joe Dinius, Ph.D.. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>