<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>A Relevant Example with CMake | Joe Dinius, Ph.D.</title> <meta name="author" content="Joe Dinius, Ph.D."> <meta name="description" content="building and exporting a package with interdependencies"> <meta name="keywords" content="robotics, autonomy, math, optimization, controltheory, planning, computervision"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?53ca2be8c4ec0d533ef79017d1a2d734"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jwdinius.github.io/blog/2018/cmake/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Joe </span>Dinius, Ph.D.</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">git</a> </li> <li class="nav-item "> <a class="nav-link" href="/learning/">learning</a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/resumeDiniusTargeted.pdf">resume</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">A Relevant Example with CMake</h1> <p class="post-meta">June 30, 2018</p> <p class="post-tags"> <a href="/blog/2018"> <i class="fa-solid fa-calendar fa-sm"></i> 2018 </a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h3 id="executive-summary">Executive Summary</h3> <p><a href="https://cmake.org" rel="external nofollow noopener" target="_blank">CMake</a> is the gold-standard for cross-platform development, yet its documentation is pretty awful. The API docs available on the developer’s site are confusing and lacking in concrete examples. Surprisingly, there are not a lot of books on the topic either. I find this last bit particularly strange considering how widely used CMake is. Doing all but the simplest <code class="language-plaintext highlighter-rouge">add_executable</code>-type projects can be very difficult. In this post, I attempt to provide a concrete example of how to use CMake to build a project with interdependencies, export/import the packages that the project built, and build unit tests. It is my hope that, with this example, many concepts about CMake will become more clear (this was certainly the case for me).</p> <h3 id="why-this-post">Why this post?</h3> <p>A lot of interesting robotics packages I have found over the last several months have used the <a href="http://wiki.ros.org/catkin/conceptual_overview" rel="external nofollow noopener" target="_blank">catkin</a> build system, which I have had only limited exposure to. For those of you not “in the know”, catkin is a build system that achieves goals of the original developers of the Robot Operating System (ROS), Willow Garage. Personally, my professional projects don’t use ROS and, thus, it becomes difficult for me to try out certain new open-source software at work because we don’t now, or ever intend to, use ROS. To bridge this gap, I wanted to find a candidate package built using ROS/catkin and convert it to native CMake, which is a universal build tool for multi-platform development. If I were to be successful in this task, conversion of other packages could be accomplished with relative ease, which would therefore enable quicker prototyping of candidate algorithms/approaches to my professional tasks.</p> <p>I’ll preface the rest of this post by saying the following: What little exposure I do have to catkin is not positive. Specifically, I have the following axes-to-grind:</p> <ul> <li> <em>In-source builds</em>. When building a catkin project, you have to put the project into your <em>catkin workspace</em> under a <code class="language-plaintext highlighter-rouge">src</code> folder. As a developer, why in the hell would I want anything other than <em>actual</em> source files under <code class="language-plaintext highlighter-rouge">src/</code>?</li> <li> <em>ROS as a dependency to build my project?</em>. To build your shiny new catkin package, you need to source a ROS environment file, which means you need ROS. Indigo, a previous ROS distribution, takes upwards of 375MB of disk space. That’s a lot of space for some stuff to help me build executables.</li> <li> <em>make and make_isolated… Seriously?</em>. I have had troubles in the past with the build process failing with some cryptic message when running <code class="language-plaintext highlighter-rouge">catkin_make</code> only to have the build process succeed with <code class="language-plaintext highlighter-rouge">catkin_make_isolated</code> and then have various problems downstream.</li> </ul> <p>Am I an expert in build systems? Definitely not. As a developer, I have mostly inherited build environments that have had the infrastructure already fully implemented, or nearly so. It may therefore be true that my understanding of what catkin is, and is not, is fundamentally flawed. Be that as it may, my understanding of what is required of <em>my</em> build systems is not flawed. I would like my build systems to observe the following rules-of-thumb:</p> <ul> <li> <em>Minimal software</em>. Ideally, I would like to just use <a href="https://cmake.org" rel="external nofollow noopener" target="_blank">cmake</a> and <a href="http://man7.org/linux/man-pages/man1/make.1.html" rel="external nofollow noopener" target="_blank">make</a>.</li> <li> <em>Out-of-source builds</em>. This means that a pristine source tree is maintained; build products are segregated.</li> <li> <em>Simple <code class="language-plaintext highlighter-rouge">install</code> and <code class="language-plaintext highlighter-rouge">uninstall</code> procedures</em>.</li> <li> <em>“superbuild” and “build individual package” capabilities</em>. Projects with multiple submodules and interdependencies should have build modes for building the whole project as well as building each submodule separately.</li> <li> <em>Export packages</em>. It should be easy to export and, more importantly, use built packages in other projects later on down-the-line.</li> <li> <em>Export ALL package dependencies</em>. This is related to the above bullet, but goes a step further. Let’s say I have two projects, <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>, and that <code class="language-plaintext highlighter-rouge">B</code> depends on <code class="language-plaintext highlighter-rouge">A</code>. If I have a third project <code class="language-plaintext highlighter-rouge">C</code> that depends on <code class="language-plaintext highlighter-rouge">B</code> alone, I should not have to import both <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> in order to build and run <code class="language-plaintext highlighter-rouge">C</code>’s targets. In other words, <code class="language-plaintext highlighter-rouge">B</code>’s export method needs to correctly handle all of its dependencies.</li> </ul> <p>I will address, in order, each of these bullet points by starting with this <a href="https://github.com/ethz-adrl/ifopt" rel="external nofollow noopener" target="_blank">GitHub repo</a>. I chose this repo because it builds projects with interdependencies, is relatively small (in terms of number of source files), has unit tests, and <em>used</em> a catkin build system. I say “used” because, since I created my fork, the repo has been updated to support a native CMake build. I should mention here that my approach is my own, not that of the original repo’s author. For my approach, please see my <a href="https://github.com/jwdinius/ifopt" rel="external nofollow noopener" target="_blank">fork</a>. I’ll begin with a brief discussion of the original repo. First, the structure:</p> <pre><code class="language-base">./
  ifopt/
  ifopt_core/
  ifopt_ipopt/
  ifopt_snopt/
  ...
</code></pre> <p><code class="language-plaintext highlighter-rouge">ifopt</code> contains the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file which sets up a <code class="language-plaintext highlighter-rouge">catkin_metapackage()</code>, which is a package of packages. Each of the remaining three folders each contain its own package: <code class="language-plaintext highlighter-rouge">src/</code>, <code class="language-plaintext highlighter-rouge">include/</code>, <code class="language-plaintext highlighter-rouge">test</code>, and a <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> to build it (again, each using <code class="language-plaintext highlighter-rouge">catkin</code>). <code class="language-plaintext highlighter-rouge">ifopt_ipopt</code> and <code class="language-plaintext highlighter-rouge">ifopt_snopt</code> each depend on the build products of <code class="language-plaintext highlighter-rouge">ifopt_core</code>; and each submodule has unit tests built with <a href="https://github.com/google/googletest.git" rel="external nofollow noopener" target="_blank">GoogleTest</a> to verify correct functionality. This small repo has a lot going on, in terms of build concerns. This is why I chose it as a starting point. In each subsequent section, I will present code snippets that demonstrate the application of my high-level requirements/desires in my final design.</p> <h4 id="minimal-software">Minimal Software</h4> <p>The original repo uses catkin, which is undesirable based upon my first bullet point above. The first objective before doing any other work was to find a way to remove all catkin dependencies, which meant eliminating <code class="language-plaintext highlighter-rouge">ifopt</code> from the build stage, entirely. To do this, I added a root-level <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code>. The metapackage-business is replaced by CMake’s <code class="language-plaintext highlighter-rouge">add_subdirectory(...)</code> macro:</p> <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># the first argument is the package root directory relative to $CMAKE_CURRENT_SOURCE_DIR</span>
<span class="c1"># the second argument is build location relative to $CMAKE_CURRENT_BINARY_DIR (the directory you ran `cmake` from)</span>
<span class="nb">add_subdirectory</span><span class="p">(</span>ifopt_core ifopt_core<span class="p">)</span>
<span class="nb">add_subdirectory</span><span class="p">(</span>ifopt_ipopt ifopt_ipopt<span class="p">)</span>
<span class="nb">add_subdirectory</span><span class="p">(</span>ifopt_snopt ifopt_snopt<span class="p">)</span>
</code></pre></div></div> <p>This basically just tells CMake to go down into these directories and execute instructions from their <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> files.</p> <p>After doing this, all catkin dependencies are gone. Woohoo!</p> <h4 id="out-of-source-builds">Out-of-Source Builds</h4> <p>This is what makes CMake so great: I can run <code class="language-plaintext highlighter-rouge">cmake path_to_CMakeLists_file</code> from anywhere I want and this will set the current directory up as a build directory. If you are deadset on having your CMake files co-mingled with source files, I believe you can do this, but it won’t be pretty! With catkin, I need to have a workspace set up, and I need to have proper environment variables sourced, and … At the end of this process, my build can only be executed in one spot, under <code class="language-plaintext highlighter-rouge">catkin_ws/src</code>. Ugh… No thanks! By setting up the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file in the project root directory, I have done away with catkin’s in-source build protocol in ( nearly ) one stroke.</p> <h4 id="simple-installuninstall">Simple Install/Uninstall</h4> <p>CMake is great at this, and why wouldn’t it be? It just builds on <code class="language-plaintext highlighter-rouge">make</code> in this regard. I have created a simple uninstall method in the root <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file. This uninstalls all build products from the superbuild at once. In contrast, each submodule can be installed individually, but the uninstall must be done in bulk. This is because I setup the uninstall target as custom, and more than one custom target in a project cannot have the same name. I suppose that I could have created a custom uninstall target within each submodule, e.g. <code class="language-plaintext highlighter-rouge">uninstall_ifopt_core</code> etc…, but this wasn’t a major concern for me. While I wanted to be able to build each submodule independently of one another, for installation my desire was different. What I really wanted when running the install/uninstall step, was to install/uninstall all project targets at once.</p> <h4 id="building-individual-packages-vs-all">Building Individual Packages vs. All</h4> <p>Because of the way the <code class="language-plaintext highlighter-rouge">add_subdirectories</code> macro works, CMake enables building all submodules together, provided you have correctly set up the interdependencies, or you can navigate to individual submodules and build them separately. CMake has the capability, but it takes some doing to set up.</p> <h4 id="export-packages">Export Packages</h4> <p>For this part, I’ll admit, the original repo wins. Catkin handles all of the heavy-lifting behind-the-scenes. The other requirements trump this one, however, so I needed to find a way to make CMake do this for me.</p> <p>This turned out to be surprisingly difficult given the lack of useful documentation. I found a few blog posts that were useful, specifically this <a href="https://rix0r.nl/blog/2015/08/13/cmake-guide/" rel="external nofollow noopener" target="_blank">one</a>, however none seemed to have concrete example code to play around with. This <a href="https://github.com/ethz-asl/kindr" rel="external nofollow noopener" target="_blank">repo</a> was very useful, and I was able to figure out a lot of what I needed to do from it, but there were pain points; the biggest of which was that the project was header-only, meaning that it did not export any libraries. Great for them and people wanting to work with their repo, but not great for me. I ended up building my solution from many Google searches and trial-and-error. The solution I arrived at came from the following considerations:</p> <ul> <li>The CMake macro <code class="language-plaintext highlighter-rouge">find_package()</code> should be used for finding both internal and external dependencies</li> <li>Packages need to export both their targets <em>and</em> their dependencies. Not doing so could create compile- and/or runtime errors.</li> </ul> <p>From <code class="language-plaintext highlighter-rouge">ifopt_core/CMakeLists.txt</code>:</p> <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set_target_properties</span><span class="p">(</span>ifopt_core PROPERTIES 
    LINK_INTERFACE_LIBRARIES <span class="si">${</span><span class="nv">PROJECT_BINARY_DIR</span><span class="si">}</span>/libifopt_core.a
    INTERFACE_INCLUDE_DIRECTORIES <span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span>/include<span class="p">)</span>

<span class="c1">############</span>
<span class="c1">## EXPORT ##</span>
<span class="c1">############</span>
<span class="c1"># for local build</span>
<span class="nb">export</span><span class="p">(</span>PACKAGE ifopt_core<span class="p">)</span>
<span class="nb">get_property</span><span class="p">(</span>ifopt_core_INCLUDE_DIRS DIRECTORY 
    <span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span> PROPERTY INCLUDE_DIRECTORIES<span class="p">)</span>
<span class="nb">get_property</span><span class="p">(</span>ifopt_core_LIBRARIES TARGET ifopt_core PROPERTY LINK_INTERFACE_LIBRARIES<span class="p">)</span> 
<span class="nb">configure_file</span><span class="p">(</span>ifopt_coreConfig.cmake.in
    <span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_BINARY_DIR</span><span class="si">}</span><span class="s2">/ifopt_coreConfig.cmake"</span> @ONLY<span class="p">)</span>
<span class="c1"># for external build</span>
<span class="nb">set</span><span class="p">(</span>ifopt_core_INCLUDE_DIRS <span class="si">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="si">}</span>/include <span class="si">${</span><span class="nv">EIGEN3_INCLUDE_DIR</span><span class="si">}</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>ifopt_core_LIBRARIES <span class="si">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="si">}</span>/lib/libifopt_core.a<span class="p">)</span>
<span class="nb">configure_file</span><span class="p">(</span>ifopt_coreConfig.cmake.in
    <span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_BINARY_DIR</span><span class="si">}${</span><span class="nv">CMAKE_FILES_DIRECTORY</span><span class="si">}</span><span class="s2">/ifopt_coreConfig.cmake"</span> @ONLY<span class="p">)</span>
</code></pre></div></div> <p>With the above snippet, I have achieved:</p> <ul> <li>The correct setup of the intermediate build product as an interface: <code class="language-plaintext highlighter-rouge">ifopt_core</code>, upon which <code class="language-plaintext highlighter-rouge">ifopt_ipopt</code> and <code class="language-plaintext highlighter-rouge">ifopt_snopt</code> depend, is built as an interface library, meaning that CMake will set it up so that consumers of this target won’t be built until after it has been built.</li> <li>The creation of both a local and a global export method setup. This ensures that both local build products and those from separate projects can set the appropriate CMake environment variables, e.g. <code class="language-plaintext highlighter-rouge">ifopt_core_INCLUDE_DIRS</code> and <code class="language-plaintext highlighter-rouge">ifopt_core_LIBRARIES</code>.</li> </ul> <p>Take note of the <code class="language-plaintext highlighter-rouge">ifopt_*Config.cmake</code> files, as these enable <code class="language-plaintext highlighter-rouge">find_package</code> to correctly set the environment variables.</p> <h4 id="export-all-package-dependencies">Export All Package Dependencies</h4> <p>CMake handles this with aplomb. To make sure that I can call <code class="language-plaintext highlighter-rouge">find_package()</code> on something which is not self-contained, I can simply do the following (from <code class="language-plaintext highlighter-rouge">./ifopt_core/CMakeLists.txt</code>):</p> <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set</span><span class="p">(</span>ifopt_ipopt_INCLUDE_DIRS <span class="si">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="si">}</span>/include include <span class="si">${</span><span class="nv">ifopt_core_INCLUDE_DIRS</span><span class="si">}</span> <span class="si">${</span><span class="nv">IPOPT_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>ifopt_ipopt_LIBRARIES <span class="si">${</span><span class="nv">CMAKE_INSTALL_PREFIX</span><span class="si">}</span>/lib/libifopt_ipopt.a <span class="si">${</span><span class="nv">ifopt_core_LIBRARIES</span><span class="si">}</span> <span class="si">${</span><span class="nv">IPOPT_LIBRARIES</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div> <p>Basically, just make sure you add all dependencies to the environment variables you wish to pull in with a <code class="language-plaintext highlighter-rouge">find_package()</code> call and it should just work.</p> <h3 id="testing">Testing</h3> <p>Now, on to the most important part: Testing. One of the main reasons I chose the original repo as a starting point was because it had several unit tests for each submodule that could be used to verify the build process. To follow along, follow the steps <a href="https://github.com/jwdinius/ifopt/blob/master/README.md" rel="external nofollow noopener" target="_blank">here</a>.</p> <p>Basically, you will need to clone the GoogleTest repo (just follow the instructions in the <a href="https://github.com/jwdinius/ifopt/blob/master/README.md" rel="external nofollow noopener" target="_blank">README</a>) and follow the remaining instructions to build. Some other things to consider:</p> <ul> <li>I don’t use SNOPT, I use IPOPT for optimization problems. You should take the SNOPT implementation with a grain-of-salt. It should work, but I did not test.</li> <li>The IPOPT install I used came from a debian package installed via <code class="language-plaintext highlighter-rouge">sudo apt install...</code>. Specific definitions for building with this library are included where appropriate (see <a href="https://github.com/jwdinius/ifopt/blob/master/ifopt_ipopt/CMakeLists.txt" rel="external nofollow noopener" target="_blank">here</a>).</li> </ul> <p>From the project root, I was able to verify that the process works by executing the following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir build ; cd build ; cmake .. -DBUILD_TEST=True
$ make
$ make test
</code></pre></div></div> <p>The output of the last step indicated that both unit tests ran successfully:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Test project /home/joe/github/ifopt/build
    Start 1: ifopt_core-test
1/2 Test <span class="c">#1: ifopt_core-test ..................   Passed    0.00 sec</span>
    Start 2: ifopt_ipopt-test
2/2 Test <span class="c">#2: ifopt_ipopt-test .................   Passed    0.01 sec</span>

100% tests passed, 0 tests failed out of 2

Total Test <span class="nb">time</span> <span class="o">(</span>real<span class="o">)</span> <span class="o">=</span>   0.02 sec
</code></pre></div></div> <p>This verifies the local export method is working as expected, since <code class="language-plaintext highlighter-rouge">ifopt_ipopt</code> used <code class="language-plaintext highlighter-rouge">find_package(ifopt_core REQUIRED)</code> in its <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file. Now, it remains to verify the external method works.</p> <p>Before doing the verification, the targets of the local build need to be installed where CMake can find them:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo make install
</code></pre></div></div> <p>To do this, I created a dummy project with the unit tests, but out of the original build tree and with a new <code class="language-plaintext highlighter-rouge">CakeLists.txt</code> file:</p> <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 2.8.3<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>ifopt_test<span class="p">)</span>

<span class="nb">add_compile_options</span><span class="p">(</span>-std=c++11<span class="p">)</span>

<span class="nb">find_package</span><span class="p">(</span>ifopt_core REQUIRED<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>ifopt_ipopt REQUIRED<span class="p">)</span>

<span class="nb">add_subdirectory</span><span class="p">(</span>third_party/gtest third_party/gtest<span class="p">)</span>
<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">gtest_SOURCE_DIR</span><span class="si">}</span>/include <span class="si">${</span><span class="nv">gtest_SOURCE_DIR</span><span class="si">}</span> 
    <span class="si">${</span><span class="nv">ifopt_core_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span>ifopt_core-test 
    src/gtest_main.cc
    src/composite_test.cc
    src/problem_test.cc
    <span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>ifopt_core-test <span class="si">${</span><span class="nv">ifopt_core_LIBRARIES</span><span class="si">}</span> gtest gtest_main pthread<span class="p">)</span>

<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">ifopt_ipopt_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span>ifopt_ipopt-test
    src/ex_test_ipopt.cc
      <span class="p">)</span>
<span class="nb">target_compile_definitions</span><span class="p">(</span>ifopt_ipopt-test PRIVATE HAVE_CSTDDEF<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>ifopt_ipopt-test <span class="si">${</span><span class="nv">ifopt_ipopt_LIBRARIES</span><span class="si">}</span> gtest gtest_main pthread<span class="p">)</span>
</code></pre></div></div> <p>The directory structure of this test project should be clear, at this point:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./
  src/
  third_party/
    gtest/
    ...
  CMakeLists.txt (the one written above)
</code></pre></div></div> <p>Inside of the <code class="language-plaintext highlighter-rouge">src</code> directory are copies of the unit test source files from the original repo. Running this shows that the executables run correctly, meaning that the global export method works as well.</p> <p>Before moving on, you should note that <code class="language-plaintext highlighter-rouge">ifopt_ipopt-test</code>, which depends upon <code class="language-plaintext highlighter-rouge">ifopt_core</code>, <code class="language-plaintext highlighter-rouge">ifopt_ipopt</code> and <code class="language-plaintext highlighter-rouge">IPOPT</code>, now only requires linkage against <code class="language-plaintext highlighter-rouge">${ifopt_ipopt_LIBRARIES}</code>, meaning that dependencies have been handled with the previously mentioned best practices in mind.</p> <h3 id="parting-thoughts">Parting Thoughts</h3> <p>In this post, I discussed, at a high-level, build systems and some things to consider when employing them to actual projects. I felt that there was a lack of useful and relevant examples online for building complicated CMake projects, so I created <a href="https://github.com/jwdinius/ifopt" rel="external nofollow noopener" target="_blank">one</a>.</p> <p>I make no claims that the approach I took and discussed above is the only one, or even that it is the best approach. I am only trying to demonstrate some features and capabilities I discovered while working with a set of simple guidelines in mind (outlined by the bullet points above). I have verified that the work presented is correct in the sense that I got meaningful outputs from the test cases considered, which were hardly exhaustive. If you believe something was done in error, feel free to leave a comment.</p> <p>I hope that this post helps you in your future work with CMake! It is highly useful for build management and, perhaps most importantly, it is free :) Thanks for reading!</p> </div> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Joe Dinius, Ph.D.. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>